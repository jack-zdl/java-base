## 算法
```
算法：
	1冒泡排序
	2快速排序
	3插入排序
	4二分法排序
	5选择排序
	6直接插入排序
	7希尔排序
	8堆排序
	时间复杂度：时间复杂度是一个函数，定量描述了算法的运算时间，用大O符号来表示。在计算的时候，先找出算法基本操作的执行次数，即为T(n)，然后找到它的同数量级，即为f(n)，如果T(n)与f(n)的比值求极限可得到一个常数c，那么时间复杂度T(n)=O(f(n))。
    上面的冒泡排序的时间复杂度计算（计算下方的for循环）：T(n) = (4n+1)n，f(n) = n*n，c = 4，则时间复杂度为：T(n) = O(n*n)
    空间复杂度：空间复杂度是运行完一个程序所需要的内存的大小。这里包括了存储算法本身所需要的空间，输入与输出数据所占空间，以及一些临时变量（比如上面的h）所占用的空间。一般而言，我们只比较额外空间，来比较算法的空间优越性。
    上面的冒泡排序的临时变量所占空间不随处理数据n的大小改变而改变，则空间复杂度为O(1)。
	时间复杂度 比如冒泡排序 排序次数 n*(n-1)/2,当n=100000,0.5(n^2-n)=0.5（10^10-100000）
	因为n是可以非常大，10^10非常大，可以忽略0.5，也可以忽略100000，简约=n^2
```
## 冒泡排序
```
   4 3 1 7 9 6 2 0
   将第一的坑填入正确的数字，比如正确排序第一个位置应该是0.所以冒泡排序是求第一位置的数字。
   时间复杂度 O(n^2)  空间复杂度 O(1)
   第一排序 以第一的数字为基数，以第二个数字跟基数比较，总是将最小的比较值放入第一坑位。一直轮询到最后一个数字。这样第一个坑位是最小的值，
            第一个坑就不改变。
   第二个排序 以第二个数字为基数，以第三个数字跟基数比较，将最小的值放在第二个坑位。
   以此类推。。。
   当排完最后一个，顺序就是从小到大的顺序。
   时间复杂度 排序次数 (n^2-n)0.5,当n很大时，就可以估算为n^2.
   空间复杂度 ： 只暂用一个格外内存，所以复杂度为O(1)
```
## 快速排序
```

```
## 3插入排序
```

```
## 二分法排序
```

```
## 选择排序
```

```
## 直接插入排序
```

```
## 希尔排序
```

```
## 堆排序
```

```

